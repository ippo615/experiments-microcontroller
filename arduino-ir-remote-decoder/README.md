Arduino IR Remote Decoder
=========================
I recently
bought myself an Arduino and I happened to have an infrared detector
too. Therefore, (obviously) I had to figure out how to use ALL of
the remote controls in my house to do something interesting. So I
ran through the house and grabbed every remote I could find. Before
I get into the "something interesting" let me tell a bit about the
IR detector.

An IR detector is microchip with a photocell. The microchip is a
demodulator that demodulates frequency modulated signals around 38 kHz,
usually from 35 kHz to 41 kHz. When there is a 38 kHz infrared signal
the detector outputs a low or 0v. When there is NO 38 kHz infrared
signal the chip outputs a high or +5v. As luck would have it: most IR
remotes use frequency modulated IR signals near 38 kHz! So pointing
a remote control at an IR detector and pressing a button will create
a stream of highs and lows. How exactly is data hidden in that stream
of highs and lows?

It would seem that there is no official IR remote protocol. The
majority of remotes seem to follow either the Philips RC5 or the
NEC infrared transmission protocol. I decided to assume that I'd be
working with NEC infrared transmission protocol because I had worked
with something similar.

So I got my Arduino up and running, connected the IR detector, wrote
some code and waited while nothing happened. Then I smelt something
burning. Turns out, I connected the detector backwards and it was
getting a little warm. I pulled the detector out and connected it.

As you may be able to tell from the diagram, the data line from the
IR detectors is connected to digital input pin 2 on the Arduino. The
detector is powered by the +5v and ground pins on the Arduino.

To start the code we define some constants:

    const int pinIR = 2;
	const int pinLED=13;
	const int CODE_LEN = 50;

`pinIR` is the pin that the data line of the IR detector is connected
to. pinLED is a pin that an LED is connected to; the UNO has a
built-in LED connected to pin 13. `CODE_LEN` is the number of pulses
that we want to monitor from the IR detector.

We'll define the variables that we'll be using:

    volatile boolean bounced = 0;
	volatile unsigned long durations[CODE_LEN];

`bounced` is a boolean used to tell us if we're already in an
interrupt. For some reason when an interrupt occurred, the interrupt
handler would be triggered twice in rapid succession. bounced can
correct this problem. `durations` is an array of pulse durations. It
will be used to store how long the data signal is high or low. The
setup code follows.

    void setup(){
      pinMode(pinIR , INPUT);
      pinMode(pinLED, OUTPUT);
      attachInterrupt(0, decodeIR, FALLING);
      digitalWrite(pinLED, LOW);
      Serial.begin(9600);
    }

In line 7 we are configuring the pin which is connected to the IR
detector as an input. Conversely, in line 8 we are ensuring our LED
is connected to an output pin. In line 9 we are saying to call the
function `decodeIR` when a `FALLING` edge occurs. `0` is simply the
interrupt number. We'll discuss the `decodeIR` function shortly. Line 10
turns off the LED and line 11 begins serial communication an 9600 baud
so we can send information back to the computer. Here is the decodeIR
function you were wondering about:

	void decodeIR(){
	  if(bounced){return;}
	  digitalWrite(pinLED, HIGH);
	  bounced = 1;
	  noInterrupts();
	  int i;
	  //for each "bit" in the code
	  for(i=0; i<CODE_LEN; i+=1){
	    //durations[i] = pulseIn(pinIR, LOW, 100000);
	    //store the duration of the pulse (microseconds)
	    durations[i] = pulseIn(pinIR, HIGH, 100000);
	  }
	  //enable interrupts
	  interrupts();
	}

We begin by checking if the bounced flag has been set. If the
bounced has been set then we should not be running this function
because either: (a) the decodeIR function has interrupted itself or
(b) we have not finished processing the last button input. Once we
determine that we should be running the decodeIR function we lite an
LED to indicate that we are doing something. Next, we set bounced
to 1; this indicates that we are monitoring and processing the IR
data. Then we disable interrupts using the noInterrupts function.

We are now at a point where we can focus on obtaining the signal
generated by the IR detector. i is a temporary variable used for
iterating. What are we iterating over? For each "bit" in the code
sequence we want to measure its duration. According to the [NEC
infrared transmission protocol documentation][NEC protocol]: a logical
"0" is a 562.5µs pulse burst followed by a 562.5µs space. At the
output of the detector we see a 562.5µs low followed by a 562.5µs high.
A logical "1" is a 562.5µs pulse burst followed by a 1687.5µs space;
at the output of the detector we see a 562.5µs low followed by a
1687.5µs high. The duration of the "low" is the same for a logical
0 or 1; however, the duration of "high" varies. Therefore, we shall
only measure the duration of the highs. Line 34 measures the duration
of the high and stores the measured duration in the appropriate slot
of the durations array.

 [NEC protocol](http://wiki.altium.com/display/ADOH/NEC+Infrared+Transmission+Protocol)

After we have gathered all of the data we enable interrupts and exit
the function. When we are not within an interrupt we are within the
main loop:

	void loop(){
	  if(bounced == 1){
	    int i;
	    Serial.println("Starting");
	    for(i=0; i<CODE_LEN; i+=1){
	      Serial.println((unsigned long)durations[i]);
	    }
	    digitalWrite(pinLED, LOW);
	    bounced = 0;
	  }
	}

The first thing we do in the main loop is check if we have new
data. When `bounced == 1` we have new data so we then transmit that data
via serial communication. The first text we send over our communication
channel is "Starting" with a new line. Then we print each measured
pulse duration on a new line. After we have printed everything,
we turn off the LED that was lit in the interrupt. Finally we set
bounced to 0. This ensures that we only send the data once and that
the interrupt will be triggered again.

Running the code on an Arduino UNO with a IR detector connected will
produced output similar to the following, after a button on an IR
remote is pressed:

	Starting
	616
	1619
	610
	506
	608
	1623
	608

Converting each output to a string of 0's and 1's (and then possibly
hex) is tedious and boring. Consequently, I made a spreadsheet to do
the dirty work for me. The spreadsheet has 5 sheets: Input, Timing,
Bit, Bin, Hex.

How do you use it?

  - First you setup your Arduino UNO as described above (now is also a good time to grab your remote and make sure it has working batteries).
  - Upload and run the code on the Arduino.
  - Open the serial communication terminal in the Arduino code editor.
  - Then open the spreadsheet.

For each button you are interested in:

  - Press the button; make sure the Arduino gives you some output.
  - Input the button name (ie 0,1,VOL+,etc...) in the "Sequence of Button Presses:" row on the "Input" sheet of the spreadsheet.

Your Arduino serial communication should be filled with a list of
numbers and your spreadsheet should have entries in the first row
from column E on.

Copy the output from the Arduino. Paste it into the first column of
the "Input" sheet of the spreadsheet. All of the other sheets should
have updated.

The "Timing" sheet shows the raw times measured for each button. Each
button is represented by a single column.

The "Bit" sheet shows the logical binary representation of the signal
for each button. Cell: C1 can be edited to change the threshold
that distinguishes between a 0 and a 1. The default is 1000. If a
timing measurement is above the threshold then it is considered a 1;
otherwise, it is considered a 0.

The "Bin" sheet groups the data from the "Bit" sheet into groups of
4. Cell D1 can be edited to change the row where we begin grouping the
bits. By default the starting row is either 5 or 6. If you wanted to
(for example) ignore then first bit then the starting row would be 6.

Finally, the "Hex" sheet converts the data from binary to hex. It is
easiest to see patterns in the data using the hex representation.

There are some flaws with the spreadsheet, for example: the spreadsheet
pretends that each button is 100 bits longs. This creates extra output
after the actual code generated by the button. Luckily it is easy to
find the beginning/end of a button because there will be an error,
black box or some other sign in that cell.
